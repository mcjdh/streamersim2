import { CONFIG } from './config/config.js';

export class UI {
    constructor(game) {
        this.game = game;
        this.selectedStreamType = localStorage.getItem('selectedStreamType') || 'gaming';
    }
    
    init() {
        // Show tutorial for new players
        if (CONFIG.SHOW_TUTORIAL && !localStorage.getItem(CONFIG.TUTORIAL_SHOWN_KEY)) {
            this.showTutorial();
        }
        
        // Initialize dark mode
        this.initDarkMode();
        
        // Initialize UI event listeners
        document.getElementById('start-stream').addEventListener('click', () => {
            if (this.selectedStreamType) {
                this.game.startStream(this.selectedStreamType);
            } else {
                this.showNotification("Select a stream type first!");
            }
        });
        
        document.getElementById('end-stream').addEventListener('click', () => {
            this.game.endStream();
        });
        
        document.getElementById('active-rest').addEventListener('click', () => {
            this.game.performActiveRest();
        });
        
        // Dark mode toggle event listener
        document.getElementById('theme-toggle').addEventListener('click', () => {
            this.toggleDarkMode();
        });
        
        // Create stream type options
        this.createStreamTypeCards();
        
        // Initial stats update
        this.updateStats();
        this.createShopItems();
        
        // Add energy bar visualization
        this.createEnergyBar();
        
        // Add keyboard controls for Pi5
        this.initKeyboardControls();
    }
      showTutorial() {
        const tutorialOverlay = document.createElement('div');
        tutorialOverlay.className = 'tutorial-overlay';
        
        const tutorialContent = document.createElement('div');
        tutorialContent.className = 'tutorial-content';
        tutorialContent.innerHTML = `
            <h2>Streamer Sim 2 - Pi Edition</h2>
            <p><strong>Goal:</strong> 1,000 subs, $5,000, 90 reputation</p>
            <p><strong>Controls:</strong></p>
            <p>• Click stream type → Start Stream</p>
            <p>• Switch types while live for variety</p>
            <p>• Rest when energy is low</p>
            <p>• Buy upgrades to grow faster</p>
            <p><strong>Keyboard shortcuts:</strong></p>
            <p>Space: Start/End | R: Rest | 1-5: Stream types</p>
            <p>Ctrl+S: Save | Ctrl+L: Load | ESC: Close dialogs</p>
            <button id="tutorial-close">Start Streaming!</button>
        `;
        
        tutorialOverlay.appendChild(tutorialContent);
        document.body.appendChild(tutorialOverlay);
        
        document.getElementById('tutorial-close').addEventListener('click', () => {
            document.body.removeChild(tutorialOverlay);
            localStorage.setItem(CONFIG.TUTORIAL_SHOWN_KEY, 'true');
        });
    }
    
    createEnergyBar() {
        const energyStatItem = document.querySelector('#energy').parentElement;
        const energyBar = document.createElement('div');
        energyBar.className = 'energy-bar';
        energyBar.innerHTML = '<div class="energy-fill"></div>';
        energyStatItem.appendChild(energyBar);
    }
    initKeyboardControls() {
        document.addEventListener('keydown', (e) => {
            // Prevent shortcuts during tutorial or if input is focused
            if (document.querySelector('.tutorial-overlay') || 
                document.activeElement.tagName === 'INPUT') {
                return;
            }
            
            switch(e.key.toLowerCase()) {
                case ' ': // Space - Start/End stream
                    e.preventDefault();
                    if (this.game.currentStream.active) {
                        document.getElementById('end-stream').click();
                    } else {
                        document.getElementById('start-stream').click();
                    }
                    break;
                case 'r': // R - Rest
                    e.preventDefault();
                    document.getElementById('active-rest').click();
                    break;
                case '1': // Stream type shortcuts
                case '2':
                case '3':
                case '4':
                case '5':
                    e.preventDefault();
                    const streamIndex = parseInt(e.key) - 1;
                    const streamTypes = CONFIG.STREAM_TYPES;
                    if (streamIndex < streamTypes.length) {
                        const streamType = streamTypes[streamIndex];
                        const isUnlocked = streamType.unlocked || 
                            (streamType.unlockAt && this.game.player.subscribers >= streamType.unlockAt);
                        if (isUnlocked) {
                            this.selectStreamType(streamType.id);
                        }
                    }
                    break;
                case 'escape': // ESC - Close tutorial/notifications
                    e.preventDefault();
                    const tutorial = document.querySelector('.tutorial-overlay');
                    if (tutorial) {
                        tutorial.querySelector('button').click();
                    }
                    break;
                case 's': // S - Save game (Ctrl+S)
                    if (e.ctrlKey) {
                        e.preventDefault();
                        this.saveGame();
                    }
                    break;
                case 'l': // L - Load game (Ctrl+L)
                    if (e.ctrlKey) {
                        e.preventDefault();
                        this.loadGame();
                    }
                    break;
            }
        });
    }
    
    saveGame() {
        this.game.saveManager.saveGame();
    }
    
    loadGame() {
        this.game.saveManager.loadGame();
    }
    
    // Mobile functions removed - Pi5 desktop only
    
    createStreamTypeCards() {
        const cardsContainer = document.getElementById('stream-type-cards');
        cardsContainer.innerHTML = '';
        
        const streamTypeEmojis = {
            'gaming': '🎮',
            'justchatting': '💬',
            'music': '🎵',
            'artstream': '🎨',
            'coding': '💻'
        };
        
        CONFIG.STREAM_TYPES.forEach(streamType => {
            const card = document.createElement('div');
            card.className = 'stream-type-card';
            
            // Check if unlocked
            const isUnlocked = streamType.unlocked || 
                (streamType.unlockAt && this.game.player.subscribers >= streamType.unlockAt);
            
            if (!isUnlocked) {
                card.classList.add('disabled');
            }
            
            // Set selected state
            if (streamType.id === this.selectedStreamType && isUnlocked) {
                card.classList.add('selected');
            }
            
            if (isUnlocked) {
                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">${streamType.name}</div>
                        <div class="card-emoji">${streamTypeEmojis[streamType.id] || '🎥'}</div>
                    </div>
                    <div class="card-stats">
                        <span>Cost: $${streamType.cost}</span>
                        <span>Energy: -${streamType.energyCost}/s</span>
                        <span>Base Viewers: ${streamType.baseViewers}</span>
                    </div>
                `;
                
                // Add accessibility attributes
                card.setAttribute('tabindex', '0');
                card.setAttribute('role', 'button');
                card.setAttribute('aria-label', `Select ${streamType.name} stream type. Cost: $${streamType.cost}`);
                
                card.addEventListener('click', () => {
                    this.selectStreamType(streamType.id);
                });
                
                // Add keyboard support
                card.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.selectStreamType(streamType.id);
                    }
                });
            } else {
                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">${streamType.name}</div>
                        <div class="card-emoji">${streamTypeEmojis[streamType.id] || '🎥'}</div>
                    </div>
                    <div class="card-unlock-info">
                        Unlock at ${streamType.unlockAt} subscribers
                    </div>
                `;
            }
            
            cardsContainer.appendChild(card);
        });
        
        this.updateQuickSwitchControls();
    }
    
    selectStreamType(streamTypeId) {
        // Remove selected class from all cards
        document.querySelectorAll('.stream-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Find and select the new card
        const cards = document.querySelectorAll('.stream-type-card');
        const streamTypeIndex = CONFIG.STREAM_TYPES.findIndex(type => type.id === streamTypeId);
        if (streamTypeIndex !== -1 && cards[streamTypeIndex]) {
            cards[streamTypeIndex].classList.add('selected');
        }
        
        this.selectedStreamType = streamTypeId;
        localStorage.setItem('selectedStreamType', streamTypeId);
        
        this.updateQuickSwitchControls();
    }
    
    updateQuickSwitchControls() {
        const quickSwitchControls = document.getElementById('quick-switch-controls');
        const quickSwitchButtons = document.getElementById('quick-switch-buttons');
        
        // Show quick switch only when streaming
        if (this.game.currentStream && this.game.currentStream.active) {
            quickSwitchControls.style.display = 'block';
            quickSwitchButtons.innerHTML = '';
            
            // Create buttons for other unlocked stream types
            CONFIG.STREAM_TYPES.forEach(streamType => {
                if (streamType.id === this.game.currentStream.type) return; // Skip current type
                
                const isUnlocked = streamType.unlocked || 
                    (streamType.unlockAt && this.game.player.subscribers >= streamType.unlockAt);
                
                if (isUnlocked) {
                    const btn = document.createElement('button');
                    btn.className = 'quick-switch-btn';
                    btn.textContent = streamType.name;
                    btn.onclick = () => this.switchStreamType(streamType.id);
                    
                    // Check if player can afford the switch
                    const canAfford = this.game.player.money >= streamType.cost;
                    const hasEnergy = this.game.player.energy >= 10; // Cost for switching
                    
                    if (!canAfford || !hasEnergy) {
                        btn.disabled = true;
                        btn.title = !canAfford ? `Need $${streamType.cost}` : 'Need more energy';
                    }
                    
                    quickSwitchButtons.appendChild(btn);
                }
            });
        } else {
            quickSwitchControls.style.display = 'none';
        }
    }
      switchStreamType(newStreamType) {
        if (!this.game.currentStream || !this.game.currentStream.active) return;
        
        const streamTypeConfig = CONFIG.STREAM_TYPES.find(type => type.id === newStreamType);
        if (!streamTypeConfig) return;
        
        // Check costs
        if (!this.game.player.spendMoney(streamTypeConfig.cost)) {
            this.showNotificationWithType("Not enough money to switch stream type!", 'error');
            return;
        }
        
        if (this.game.player.energy < 10) {
            this.showNotificationWithType("Not enough energy to switch stream type!", 'error');
            return;
        }
        
        // Add loading effect to the target card
        const cards = document.querySelectorAll('.stream-type-card');
        const streamTypeIndex = CONFIG.STREAM_TYPES.findIndex(type => type.id === newStreamType);
        if (streamTypeIndex !== -1 && cards[streamTypeIndex]) {
            cards[streamTypeIndex].classList.add('loading');
        }
        
        // Apply switch cost and change type
        this.game.player.useEnergy(10);
        this.game.currentStream.type = newStreamType;
        
        // Update display with delay for better UX
        setTimeout(() => {
            if (streamTypeIndex !== -1 && cards[streamTypeIndex]) {
                cards[streamTypeIndex].classList.remove('loading');
            }
            
            this.updateStreamDisplay(newStreamType);
            this.selectStreamType(newStreamType);
            this.logEvent(`Switched to ${streamTypeConfig.name} stream!`);
            this.showNotificationWithType(`Switched to ${streamTypeConfig.name}!`, 'success');
            
            // Recalculate energy drain rate for new stream type
            this.game.currentStream.calculateEnergyDrainRate(streamTypeConfig);
            
            // Update quick switch controls
            this.updateQuickSwitchControls();
            
            // Add pulse effect to viewer count to indicate potential change
            this.addPulseEffect('viewers-count');
        }, 300);
    }
    
    createShopItems() {
        const shopItemsContainer = document.getElementById('shop-items-container');
        shopItemsContainer.innerHTML = ''; // Clear existing items

        CONFIG.SHOP_ITEMS.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'shop-item';

            const itemName = document.createElement('h4');
            itemName.textContent = item.name;

            const itemDesc = document.createElement('p');
            itemDesc.textContent = item.description;

            const itemCost = document.createElement('p');
            itemCost.textContent = `Cost: $${item.cost}`;

            const buyButton = document.createElement('button');
            buyButton.textContent = "Buy";
            buyButton.onclick = () => {
                this.game.player.buyItem(item.id);
                // Future: Could update shop UI here if item is single purchase
            };

            itemDiv.appendChild(itemName);
            itemDiv.appendChild(itemDesc);
            itemDiv.appendChild(itemCost);
            itemDiv.appendChild(buyButton);
            shopItemsContainer.appendChild(itemDiv);
        });
    }
    
    updateStats() {
        document.getElementById('subscribers').textContent = this.game.player.subscribers;
        document.getElementById('money').textContent = this.game.player.money;
        document.getElementById('reputation').textContent = this.game.player.reputation;
        document.getElementById('energy').textContent = Math.floor(this.game.player.energy);
        
        // Update energy bar
        const energyPercent = (this.game.player.energy / this.game.player.maxEnergy) * 100;
        const energyFill = document.querySelector('.energy-fill');
        if (energyFill) {
            energyFill.style.width = `${energyPercent}%`;
            
            // Change color based on energy level
            energyFill.classList.remove('low', 'medium');
            if (energyPercent < 30) {
                energyFill.classList.add('low');
            } else if (energyPercent < 60) {
                energyFill.classList.add('medium');
            }
        }
        
        // Check for newly unlocked stream types
        this.checkStreamUnlocks();
    }
      checkStreamUnlocks() {
        CONFIG.STREAM_TYPES.forEach(streamType => {
            if (streamType.unlockAt && !streamType.unlocked && 
                this.game.player.subscribers >= streamType.unlockAt) {
                streamType.unlocked = true;
                this.showNotification(`${streamType.name} streams unlocked!`);
                this.createStreamTypeCards(); // Refresh cards
            }
        });
    }
      updateStreamDisplay(streamType) {
        const streamVideoFeed = document.getElementById('stream-video-feed');
        
        if (!streamType) {
            streamVideoFeed.innerHTML = '<div class="offline-message">Stream Offline</div>';
            document.getElementById('chat-log').innerHTML = '';
            return;
        }
        
        let content = '';
        switch(streamType) {
            case 'gaming':
                content = '<div class="stream-gaming">🎮 Gaming Stream</div>';
                break;
            case 'justchatting':
                content = '<div class="stream-chat">💬 Just Chatting</div>';
                break;
            case 'music':
                content = '<div class="stream-music">🎵 Music Stream</div>';
                break;
            case 'artstream':
                content = '<div class="stream-art">🎨 Art Stream</div>';
                break;
            case 'coding':
                content = '<div class="stream-coding">💻 Coding Stream</div>';
                break;
            default:
                content = '<div class="stream-generic">🎥 Live Stream</div>';
        }
        
        streamVideoFeed.innerHTML = content;
    }
    
    updateViewerCount(count) {
        document.getElementById('viewers-count').textContent = `Viewers: ${count}`;
    }
    
    updateStreamTimer(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        const formattedTime = 
            `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        document.getElementById('stream-timer').textContent = formattedTime;
        
        // Add visual indicator when approaching target duration
        const targetReached = seconds >= this.game.currentStream.targetDuration;
        const timerElement = document.getElementById('stream-timer');
        if (targetReached) {
            timerElement.style.color = '#00ff00';
        } else {
            timerElement.style.color = '#ffffff';
        }
    }
      toggleStreamControls(isStreaming) {
        document.getElementById('start-stream').disabled = isStreaming;
        document.getElementById('end-stream').disabled = !isStreaming;
        document.getElementById('active-rest').disabled = isStreaming; // Enable/disable rest button
        
        // Update stream type cards - disable switching when not streaming
        const streamTypeCards = document.querySelectorAll('.stream-type-card:not(.disabled)');
        streamTypeCards.forEach(card => {
            if (isStreaming) {
                card.style.pointerEvents = 'none';
                card.style.opacity = '0.7';
            } else {
                card.style.pointerEvents = 'auto';
                card.style.opacity = '1';
            }
        });
        
        // Update quick switch controls
        this.updateQuickSwitchControls();
    }
    
    highlightEndStream() {
        const endStreamButton = document.getElementById('end-stream');
        endStreamButton.classList.add('highlight');
        setTimeout(() => {
            endStreamButton.classList.remove('highlight');
        }, 500);
    }
    
    logEvent(message) {
        const eventsLog = document.getElementById('events-log');
        const entry = document.createElement('div');
        entry.className = 'event-entry';
        
        // Add timestamp
        const now = new Date();
        const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        
        entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
        eventsLog.appendChild(entry);
        
        // Limit log entries
        while (eventsLog.children.length > CONFIG.LOG_MAX_ENTRIES) {
            eventsLog.removeChild(eventsLog.firstChild);
        }
        
        // Auto-scroll to bottom
        eventsLog.scrollTop = eventsLog.scrollHeight;
    }
    
    showNotification(message) {
        const notificationArea = document.getElementById('notification-area');
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        
        notificationArea.appendChild(notification);
        
        // Remove notification after animation
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
    
    showNotificationWithType(message, type = 'info') {
        const notificationArea = document.getElementById('notification-area');
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        
        notificationArea.appendChild(notification);
        
        // Remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }
    
    addPulseEffect(elementId) {
        const element = document.getElementById(elementId);
        if (element) {
            element.classList.add('pulse');
            setTimeout(() => {
                element.classList.remove('pulse');
            }, 3000);
        }
    }
    
    showDonation(amount) {
        const streamVideoFeed = document.getElementById('stream-video-feed');
        const donation = document.createElement('div');
        donation.className = 'donation-animation';
        donation.textContent = `$${amount}`;
        donation.style.position = 'absolute';
        donation.style.left = `${Math.random() * 60 + 20}%`;
        donation.style.top = `${Math.random() * 60 + 20}%`;
        donation.style.color = '#ffcc00';
        donation.style.fontWeight = 'bold';
        donation.style.fontSize = '24px';
        donation.style.textShadow = '0 0 5px rgba(0,0,0,0.8)';
        donation.style.animation = 'donationFloat 2s forwards';
        
        streamVideoFeed.appendChild(donation);
        
        setTimeout(() => {
            donation.remove();
        }, 2000);
          this.logEvent(`Received a $${amount} donation!`);
        this.game.chatManager.postDonationReaction("GenerousViewer", amount);
    }
    
    addChatMessage(username, messageText, userColor = '#ffffff') {
        const chatLog = document.getElementById('chat-log');
        const messageEntry = document.createElement('div');
        messageEntry.className = 'chat-message';

        // Parse username for badges
        const userSpan = document.createElement('span');
        userSpan.className = 'chat-username';
        userSpan.innerHTML = `${username}: `; // Using innerHTML to support badges
        userSpan.style.color = userColor;
        userSpan.style.fontWeight = 'bold';

        const textSpan = document.createElement('span');
        textSpan.className = 'chat-text';
        textSpan.innerHTML = messageText; // Using innerHTML to support emotes

        // Determine if chat should auto-scroll BEFORE appending the new message
        // and before removing old messages, as scrollHeight will change.
        const scrollThreshold = 20; // How many pixels from bottom to still consider "at bottom"
        const isScrolledNearBottom = chatLog.scrollTop + chatLog.clientHeight >= chatLog.scrollHeight - scrollThreshold;

        messageEntry.appendChild(userSpan);
        messageEntry.appendChild(textSpan);
        chatLog.appendChild(messageEntry);

        // Limit chat messages for performance
        while (chatLog.children.length > CONFIG.CHAT_MAX_ENTRIES) {
            chatLog.removeChild(chatLog.firstChild);
        }
        
        // Auto-scroll to bottom only if user was already near the bottom
        if (isScrolledNearBottom) {
            chatLog.scrollTop = chatLog.scrollHeight - chatLog.clientHeight; // Precise scroll to bottom
        }
    }
    
    showVictoryScreen() {
        const gameContainer = document.getElementById('game-container');
        
        // Create victory overlay
        const victoryOverlay = document.createElement('div');
        victoryOverlay.id = 'victory-overlay';
        victoryOverlay.style.position = 'fixed';
        victoryOverlay.style.top = '0';
        victoryOverlay.style.left = '0';
        victoryOverlay.style.width = '100%';
        victoryOverlay.style.height = '100%';
        victoryOverlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
        victoryOverlay.style.display = 'flex';
        victoryOverlay.style.flexDirection = 'column';
        victoryOverlay.style.alignItems = 'center';
        victoryOverlay.style.justifyContent = 'center';
        victoryOverlay.style.color = '#ffffff';
        victoryOverlay.style.zIndex = '100';
        
        // Victory content
        const victoryContent = document.createElement('div');
        victoryContent.innerHTML = `
            <h1 style="color: #9147ff; font-size: 48px; margin-bottom: 20px;">CONGRATULATIONS!</h1>
            <h2>You've become a successful streamer!</h2>
            <p style="margin: 20px 0;">Final stats:</p>
            <ul style="list-style: none; padding: 0; text-align: center; margin-bottom: 20px;">
                <li>Subscribers: ${this.game.player.subscribers}</li>
                <li>Money: $${this.game.player.money}</li>
                <li>Reputation: ${this.game.player.reputation}</li>
                <li>Streams completed: ${this.game.player.stats.streamsCompleted}</li>
                <li>Total streaming time: ${Math.floor(this.game.player.stats.totalStreamTime / 60)} minutes</li>
                <li>Peak viewers: ${this.game.player.stats.maxViewers}</li>
            </ul>
            <button id="play-again" style="margin-top: 20px;">Play Again</button>
        `;
        
        victoryOverlay.appendChild(victoryContent);
        document.body.appendChild(victoryOverlay);
        
        // Add event listener to play again button
        document.getElementById('play-again').addEventListener('click', () => {
            document.body.removeChild(victoryOverlay);
            this.game.reset();
        });
    }
    
    initDarkMode() {
        // Get saved theme preference or detect system preference
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        let theme;
        if (savedTheme) {
            theme = savedTheme;
        } else {
            theme = systemPrefersDark ? 'dark' : 'light';
        }
        
        this.setTheme(theme);
        
        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) { // Only follow system if no manual preference
                this.setTheme(e.matches ? 'dark' : 'light');
            }
        });
    }
    
    setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        
        // Update toggle button icon
        const toggleBtn = document.getElementById('theme-toggle');
        if (toggleBtn) {
            toggleBtn.textContent = theme === 'dark' ? '☀️' : '🌙';
            toggleBtn.title = `Switch to ${theme === 'dark' ? 'light' : 'dark'} mode`;
        }
    }
    
    toggleDarkMode() {
        const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        
        this.setTheme(newTheme);
        localStorage.setItem('theme', newTheme);
        
        // Show notification
        this.showNotification(`Switched to ${newTheme} mode`);
    }
}